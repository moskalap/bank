# -*- coding: utf-8 -*-
# **********************************************************************
#
# Copyright (c) 2003-2018 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.7.1
#
# <auto-generated>
#
# Generated from file `bank.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module Bank
_M_Bank = Ice.openModule('Bank')
__name__ = 'Bank'

if 'Currency' not in _M_Bank.__dict__:
    _M_Bank.Currency = Ice.createTempClass()
    class Currency(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    Currency.PLN = Currency("PLN", 0)
    Currency.USD = Currency("USD", 1)
    Currency.EUR = Currency("EUR", 2)
    Currency.GBP = Currency("GBP", 3)
    Currency.CHF = Currency("CHF", 4)
    Currency._enumerators = { 0:Currency.PLN, 1:Currency.USD, 2:Currency.EUR, 3:Currency.GBP, 4:Currency.CHF }

    _M_Bank._t_Currency = IcePy.defineEnum('::Bank::Currency', Currency, (), Currency._enumerators)

    _M_Bank.Currency = Currency
    del Currency

if 'AccountError' not in _M_Bank.__dict__:
    _M_Bank.AccountError = Ice.createTempClass()
    class AccountError(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    AccountError.AMOUNTNEGATIVE = AccountError("AMOUNTNEGATIVE", 0)
    AccountError.PESELNOTNUMERIC = AccountError("PESELNOTNUMERIC", 1)
    AccountError.PESELLENGTH = AccountError("PESELLENGTH", 2)
    AccountError.ACCNTDONTEXIST = AccountError("ACCNTDONTEXIST", 3)
    AccountError._enumerators = { 0:AccountError.AMOUNTNEGATIVE, 1:AccountError.PESELNOTNUMERIC, 2:AccountError.PESELLENGTH, 3:AccountError.ACCNTDONTEXIST }

    _M_Bank._t_AccountError = IcePy.defineEnum('::Bank::AccountError', AccountError, (), AccountError._enumerators)

    _M_Bank.AccountError = AccountError
    del AccountError

if 'CreditInfoError' not in _M_Bank.__dict__:
    _M_Bank.CreditInfoError = Ice.createTempClass()
    class CreditInfoError(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    CreditInfoError.AMOUNTNEGATIVE = CreditInfoError("AMOUNTNEGATIVE", 0)
    CreditInfoError.DATEPAST = CreditInfoError("DATEPAST", 1)
    CreditInfoError._enumerators = { 0:CreditInfoError.AMOUNTNEGATIVE, 1:CreditInfoError.DATEPAST }

    _M_Bank._t_CreditInfoError = IcePy.defineEnum('::Bank::CreditInfoError', CreditInfoError, (), CreditInfoError._enumerators)

    _M_Bank.CreditInfoError = CreditInfoError
    del CreditInfoError

if 'AccountCategory' not in _M_Bank.__dict__:
    _M_Bank.AccountCategory = Ice.createTempClass()
    class AccountCategory(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    AccountCategory.STANDARD = AccountCategory("STANDARD", 0)
    AccountCategory.PREMIUM = AccountCategory("PREMIUM", 1)
    AccountCategory._enumerators = { 0:AccountCategory.STANDARD, 1:AccountCategory.PREMIUM }

    _M_Bank._t_AccountCategory = IcePy.defineEnum('::Bank::AccountCategory', AccountCategory, (), AccountCategory._enumerators)

    _M_Bank.AccountCategory = AccountCategory
    del AccountCategory

if 'Money' not in _M_Bank.__dict__:
    _M_Bank.Money = Ice.createTempClass()
    class Money(object):
        def __init__(self, value=0.0, currency=_M_Bank.Currency.PLN):
            self.value = value
            self.currency = currency

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Bank.Money):
                return NotImplemented
            else:
                if self.value != other.value:
                    return False
                if self.currency != other.currency:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Bank._t_Money)

        __repr__ = __str__

    _M_Bank._t_Money = IcePy.defineStruct('::Bank::Money', Money, (), (
        ('value', (), IcePy._t_float),
        ('currency', (), _M_Bank._t_Currency)
    ))

    _M_Bank.Money = Money
    del Money

if 'Date' not in _M_Bank.__dict__:
    _M_Bank.Date = Ice.createTempClass()
    class Date(object):
        def __init__(self, day=0, month=0, year=0):
            self.day = day
            self.month = month
            self.year = year

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.day)
            _h = 5 * _h + Ice.getHash(self.month)
            _h = 5 * _h + Ice.getHash(self.year)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Bank.Date):
                return NotImplemented
            else:
                if self.day is None or other.day is None:
                    if self.day != other.day:
                        return (-1 if self.day is None else 1)
                else:
                    if self.day < other.day:
                        return -1
                    elif self.day > other.day:
                        return 1
                if self.month is None or other.month is None:
                    if self.month != other.month:
                        return (-1 if self.month is None else 1)
                else:
                    if self.month < other.month:
                        return -1
                    elif self.month > other.month:
                        return 1
                if self.year is None or other.year is None:
                    if self.year != other.year:
                        return (-1 if self.year is None else 1)
                else:
                    if self.year < other.year:
                        return -1
                    elif self.year > other.year:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Bank._t_Date)

        __repr__ = __str__

    _M_Bank._t_Date = IcePy.defineStruct('::Bank::Date', Date, (), (
        ('day', (), IcePy._t_short),
        ('month', (), IcePy._t_short),
        ('year', (), IcePy._t_int)
    ))

    _M_Bank.Date = Date
    del Date

if 'Person' not in _M_Bank.__dict__:
    _M_Bank.Person = Ice.createTempClass()
    class Person(object):
        def __init__(self, name='', surname='', pesel=''):
            self.name = name
            self.surname = surname
            self.pesel = pesel

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.name)
            _h = 5 * _h + Ice.getHash(self.surname)
            _h = 5 * _h + Ice.getHash(self.pesel)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Bank.Person):
                return NotImplemented
            else:
                if self.name is None or other.name is None:
                    if self.name != other.name:
                        return (-1 if self.name is None else 1)
                else:
                    if self.name < other.name:
                        return -1
                    elif self.name > other.name:
                        return 1
                if self.surname is None or other.surname is None:
                    if self.surname != other.surname:
                        return (-1 if self.surname is None else 1)
                else:
                    if self.surname < other.surname:
                        return -1
                    elif self.surname > other.surname:
                        return 1
                if self.pesel is None or other.pesel is None:
                    if self.pesel != other.pesel:
                        return (-1 if self.pesel is None else 1)
                else:
                    if self.pesel < other.pesel:
                        return -1
                    elif self.pesel > other.pesel:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Bank._t_Person)

        __repr__ = __str__

    _M_Bank._t_Person = IcePy.defineStruct('::Bank::Person', Person, (), (
        ('name', (), IcePy._t_string),
        ('surname', (), IcePy._t_string),
        ('pesel', (), IcePy._t_string)
    ))

    _M_Bank.Person = Person
    del Person

if 'CreditInfo' not in _M_Bank.__dict__:
    _M_Bank.CreditInfo = Ice.createTempClass()
    class CreditInfo(object):
        def __init__(self, localCurrency=Ice._struct_marker, foreignCurrency=Ice._struct_marker):
            if localCurrency is Ice._struct_marker:
                self.localCurrency = _M_Bank.Money()
            else:
                self.localCurrency = localCurrency
            if foreignCurrency is Ice._struct_marker:
                self.foreignCurrency = _M_Bank.Money()
            else:
                self.foreignCurrency = foreignCurrency

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Bank.CreditInfo):
                return NotImplemented
            else:
                if self.localCurrency != other.localCurrency:
                    return False
                if self.foreignCurrency != other.foreignCurrency:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Bank._t_CreditInfo)

        __repr__ = __str__

    _M_Bank._t_CreditInfo = IcePy.defineStruct('::Bank::CreditInfo', CreditInfo, (), (
        ('localCurrency', (), _M_Bank._t_Money),
        ('foreignCurrency', (), _M_Bank._t_Money)
    ))

    _M_Bank.CreditInfo = CreditInfo
    del CreditInfo

if 'BankException' not in _M_Bank.__dict__:
    _M_Bank.BankException = Ice.createTempClass()
    class BankException(Ice.UserException):
        def __init__(self, msg=''):
            self.msg = msg

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Bank::BankException'

    _M_Bank._t_BankException = IcePy.defineException('::Bank::BankException', BankException, (), False, None, (('msg', (), IcePy._t_string, False, 0),))
    BankException._ice_type = _M_Bank._t_BankException

    _M_Bank.BankException = BankException
    del BankException

if 'AccountException' not in _M_Bank.__dict__:
    _M_Bank.AccountException = Ice.createTempClass()
    class AccountException(_M_Bank.BankException):
        def __init__(self, msg='', errorType=_M_Bank.AccountError.AMOUNTNEGATIVE):
            _M_Bank.BankException.__init__(self, msg)
            self.errorType = errorType

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Bank::AccountException'

    _M_Bank._t_AccountException = IcePy.defineException('::Bank::AccountException', AccountException, (), False, _M_Bank._t_BankException, (('errorType', (), _M_Bank._t_AccountError, False, 0),))
    AccountException._ice_type = _M_Bank._t_AccountException

    _M_Bank.AccountException = AccountException
    del AccountException

if 'CreditInfoException' not in _M_Bank.__dict__:
    _M_Bank.CreditInfoException = Ice.createTempClass()
    class CreditInfoException(_M_Bank.BankException):
        def __init__(self, msg='', error=_M_Bank.CreditInfoError.AMOUNTNEGATIVE):
            _M_Bank.BankException.__init__(self, msg)
            self.error = error

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Bank::CreditInfoException'

    _M_Bank._t_CreditInfoException = IcePy.defineException('::Bank::CreditInfoException', CreditInfoException, (), False, _M_Bank._t_BankException, (('error', (), _M_Bank._t_CreditInfoError, False, 0),))
    CreditInfoException._ice_type = _M_Bank._t_CreditInfoException

    _M_Bank.CreditInfoException = CreditInfoException
    del CreditInfoException

_M_Bank._t_Account = IcePy.defineValue('::Bank::Account', Ice.Value, -1, (), False, True, None, ())

if 'AccountPrx' not in _M_Bank.__dict__:
    _M_Bank.AccountPrx = Ice.createTempClass()
    class AccountPrx(Ice.ObjectPrx):

        def getAccountId(self, context=None):
            return _M_Bank.Account._op_getAccountId.invoke(self, ((), context))

        def getAccountIdAsync(self, context=None):
            return _M_Bank.Account._op_getAccountId.invokeAsync(self, ((), context))

        def begin_getAccountId(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Bank.Account._op_getAccountId.begin(self, ((), _response, _ex, _sent, context))

        def end_getAccountId(self, _r):
            return _M_Bank.Account._op_getAccountId.end(self, _r)

        def getMoneyAmount(self, context=None):
            return _M_Bank.Account._op_getMoneyAmount.invoke(self, ((), context))

        def getMoneyAmountAsync(self, context=None):
            return _M_Bank.Account._op_getMoneyAmount.invokeAsync(self, ((), context))

        def begin_getMoneyAmount(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Bank.Account._op_getMoneyAmount.begin(self, ((), _response, _ex, _sent, context))

        def end_getMoneyAmount(self, _r):
            return _M_Bank.Account._op_getMoneyAmount.end(self, _r)

        def getLocalCurrencyCreditInfo(self, amount, endOfContract, context=None):
            return _M_Bank.Account._op_getLocalCurrencyCreditInfo.invoke(self, ((amount, endOfContract), context))

        def getLocalCurrencyCreditInfoAsync(self, amount, endOfContract, context=None):
            return _M_Bank.Account._op_getLocalCurrencyCreditInfo.invokeAsync(self, ((amount, endOfContract), context))

        def begin_getLocalCurrencyCreditInfo(self, amount, endOfContract, _response=None, _ex=None, _sent=None, context=None):
            return _M_Bank.Account._op_getLocalCurrencyCreditInfo.begin(self, ((amount, endOfContract), _response, _ex, _sent, context))

        def end_getLocalCurrencyCreditInfo(self, _r):
            return _M_Bank.Account._op_getLocalCurrencyCreditInfo.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Bank.AccountPrx.ice_checkedCast(proxy, '::Bank::Account', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Bank.AccountPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Bank::Account'
    _M_Bank._t_AccountPrx = IcePy.defineProxy('::Bank::Account', AccountPrx)

    _M_Bank.AccountPrx = AccountPrx
    del AccountPrx

    _M_Bank.Account = Ice.createTempClass()
    class Account(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Bank::Account', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Bank::Account'

        @staticmethod
        def ice_staticId():
            return '::Bank::Account'

        def getAccountId(self, current=None):
            raise NotImplementedError("servant method 'getAccountId' not implemented")

        def getMoneyAmount(self, current=None):
            raise NotImplementedError("servant method 'getMoneyAmount' not implemented")

        def getLocalCurrencyCreditInfo(self, amount, endOfContract, current=None):
            raise NotImplementedError("servant method 'getLocalCurrencyCreditInfo' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Bank._t_AccountDisp)

        __repr__ = __str__

    _M_Bank._t_AccountDisp = IcePy.defineClass('::Bank::Account', Account, (), None, ())
    Account._ice_type = _M_Bank._t_AccountDisp

    Account._op_getAccountId = IcePy.Operation('getAccountId', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())
    Account._op_getMoneyAmount = IcePy.Operation('getMoneyAmount', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Bank._t_Money, False, 0), ())
    Account._op_getLocalCurrencyCreditInfo = IcePy.Operation('getLocalCurrencyCreditInfo', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_float, False, 0), ((), _M_Bank._t_Date, False, 0)), (), ((), _M_Bank._t_CreditInfo, False, 0), (_M_Bank._t_CreditInfoException,))

    _M_Bank.Account = Account
    del Account

_M_Bank._t_PremiumAccount = IcePy.defineValue('::Bank::PremiumAccount', Ice.Value, -1, (), False, True, None, ())

if 'PremiumAccountPrx' not in _M_Bank.__dict__:
    _M_Bank.PremiumAccountPrx = Ice.createTempClass()
    class PremiumAccountPrx(_M_Bank.AccountPrx):

        def getForeignCurrencyCreditInfo(self, amount, endOfContract, context=None):
            return _M_Bank.PremiumAccount._op_getForeignCurrencyCreditInfo.invoke(self, ((amount, endOfContract), context))

        def getForeignCurrencyCreditInfoAsync(self, amount, endOfContract, context=None):
            return _M_Bank.PremiumAccount._op_getForeignCurrencyCreditInfo.invokeAsync(self, ((amount, endOfContract), context))

        def begin_getForeignCurrencyCreditInfo(self, amount, endOfContract, _response=None, _ex=None, _sent=None, context=None):
            return _M_Bank.PremiumAccount._op_getForeignCurrencyCreditInfo.begin(self, ((amount, endOfContract), _response, _ex, _sent, context))

        def end_getForeignCurrencyCreditInfo(self, _r):
            return _M_Bank.PremiumAccount._op_getForeignCurrencyCreditInfo.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Bank.PremiumAccountPrx.ice_checkedCast(proxy, '::Bank::PremiumAccount', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Bank.PremiumAccountPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Bank::PremiumAccount'
    _M_Bank._t_PremiumAccountPrx = IcePy.defineProxy('::Bank::PremiumAccount', PremiumAccountPrx)

    _M_Bank.PremiumAccountPrx = PremiumAccountPrx
    del PremiumAccountPrx

    _M_Bank.PremiumAccount = Ice.createTempClass()
    class PremiumAccount(_M_Bank.Account):

        def ice_ids(self, current=None):
            return ('::Bank::Account', '::Bank::PremiumAccount', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Bank::PremiumAccount'

        @staticmethod
        def ice_staticId():
            return '::Bank::PremiumAccount'

        def getForeignCurrencyCreditInfo(self, amount, endOfContract, current=None):
            raise NotImplementedError("servant method 'getForeignCurrencyCreditInfo' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Bank._t_PremiumAccountDisp)

        __repr__ = __str__

    _M_Bank._t_PremiumAccountDisp = IcePy.defineClass('::Bank::PremiumAccount', PremiumAccount, (), None, (_M_Bank._t_AccountDisp,))
    PremiumAccount._ice_type = _M_Bank._t_PremiumAccountDisp

    PremiumAccount._op_getForeignCurrencyCreditInfo = IcePy.Operation('getForeignCurrencyCreditInfo', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Bank._t_Money, False, 0), ((), _M_Bank._t_Date, False, 0)), (), ((), _M_Bank._t_CreditInfo, False, 0), (_M_Bank._t_CreditInfoException,))

    _M_Bank.PremiumAccount = PremiumAccount
    del PremiumAccount

_M_Bank._t_BankService = IcePy.defineValue('::Bank::BankService', Ice.Value, -1, (), False, True, None, ())

if 'BankServicePrx' not in _M_Bank.__dict__:
    _M_Bank.BankServicePrx = Ice.createTempClass()
    class BankServicePrx(Ice.ObjectPrx):

        def createAccount(self, person, declaredIncome, amount, context=None):
            return _M_Bank.BankService._op_createAccount.invoke(self, ((person, declaredIncome, amount), context))

        def createAccountAsync(self, person, declaredIncome, amount, context=None):
            return _M_Bank.BankService._op_createAccount.invokeAsync(self, ((person, declaredIncome, amount), context))

        def begin_createAccount(self, person, declaredIncome, amount, _response=None, _ex=None, _sent=None, context=None):
            return _M_Bank.BankService._op_createAccount.begin(self, ((person, declaredIncome, amount), _response, _ex, _sent, context))

        def end_createAccount(self, _r):
            return _M_Bank.BankService._op_createAccount.end(self, _r)

        def getAccount(self, guid, context=None):
            return _M_Bank.BankService._op_getAccount.invoke(self, ((guid, ), context))

        def getAccountAsync(self, guid, context=None):
            return _M_Bank.BankService._op_getAccount.invokeAsync(self, ((guid, ), context))

        def begin_getAccount(self, guid, _response=None, _ex=None, _sent=None, context=None):
            return _M_Bank.BankService._op_getAccount.begin(self, ((guid, ), _response, _ex, _sent, context))

        def end_getAccount(self, _r):
            return _M_Bank.BankService._op_getAccount.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Bank.BankServicePrx.ice_checkedCast(proxy, '::Bank::BankService', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Bank.BankServicePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Bank::BankService'
    _M_Bank._t_BankServicePrx = IcePy.defineProxy('::Bank::BankService', BankServicePrx)

    _M_Bank.BankServicePrx = BankServicePrx
    del BankServicePrx

    _M_Bank.BankService = Ice.createTempClass()
    class BankService(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Bank::BankService', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Bank::BankService'

        @staticmethod
        def ice_staticId():
            return '::Bank::BankService'

        def createAccount(self, person, declaredIncome, amount, current=None):
            raise NotImplementedError("servant method 'createAccount' not implemented")

        def getAccount(self, guid, current=None):
            raise NotImplementedError("servant method 'getAccount' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Bank._t_BankServiceDisp)

        __repr__ = __str__

    _M_Bank._t_BankServiceDisp = IcePy.defineClass('::Bank::BankService', BankService, (), None, ())
    BankService._ice_type = _M_Bank._t_BankServiceDisp

    BankService._op_createAccount = IcePy.Operation('createAccount', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Bank._t_Person, False, 0), ((), _M_Bank._t_Money, False, 0), ((), _M_Bank._t_Money, False, 0)), (), ((), _M_Bank._t_AccountPrx, False, 0), (_M_Bank._t_AccountException,))
    BankService._op_getAccount = IcePy.Operation('getAccount', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), _M_Bank._t_AccountPrx, False, 0), (_M_Bank._t_AccountException,))

    _M_Bank.BankService = BankService
    del BankService

# End of module Bank
